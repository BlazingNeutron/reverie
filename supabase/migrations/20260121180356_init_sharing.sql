
ALTER TABLE doc_index RENAME TO documents;

CREATE OR REPLACE FUNCTION UPDATE_DOC_ID_TO_UUID() 
  RETURNS VOID 
AS
$$
DECLARE 
   t_row documents%rowtype;
   temp_uuid uuid;
BEGIN
    FOR t_row in SELECT * FROM documents LOOP
        SELECT gen_random_uuid() INTO temp_uuid;
        update documents
            set doc_id = temp_uuid
        where doc_id = t_row.doc_id;
        update yjs_updates
            set doc_id = temp_uuid
        where doc_id = t_row.doc_id;
    END LOOP;
END;
$$ 
LANGUAGE plpgsql;
select UPDATE_DOC_ID_TO_UUID();
DROP FUNCTION UPDATE_DOC_ID_TO_UUID();

ALTER TABLE documents ALTER COLUMN doc_id TYPE uuid USING (gen_random_uuid());
ALTER TABLE documents ALTER doc_id SET DEFAULT gen_random_uuid();

ALTER TABLE yjs_updates ALTER COLUMN doc_id TYPE uuid USING (gen_random_uuid());

ALTER TABLE ONLY "public"."yjs_updates"
    ADD CONSTRAINT "yjs_updates_doc_id_fkey" FOREIGN KEY ("doc_id") REFERENCES "public"."documents"("doc_id") ON DELETE CASCADE;

ALTER TABLE public.documents DROP CONSTRAINT doc_index_user_id_fkey;

ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "doc_index_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE public.yjs_updates DROP CONSTRAINT yjs_updates_user_id_fkey;

ALTER TABLE ONLY "public"."yjs_updates"
    ADD CONSTRAINT "yjs_updates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE TABLE IF NOT EXISTS "public"."shared" (
  id bigint generated by default as identity not null,
  doc_id uuid not null default gen_random_uuid (),
  user_id uuid not null default gen_random_uuid (),
  constraint shared_pkey primary key (id),
  constraint shared_doc_id_fkey foreign KEY (doc_id) references documents (doc_id) on delete CASCADE,
  constraint shared_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

CREATE POLICY "Enable users to view their own data only" ON "public"."shared" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."shared" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable delete for users based on user_id" ON "public"."shared" FOR DELETE USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

ALTER TABLE "public"."shared" ENABLE ROW LEVEL SECURITY;

GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."shared" TO "anon";
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."shared" TO "authenticated";
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."shared" TO "service_role";

CREATE TABLE IF NOT EXISTS public.profiles (
    user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name text,
    username text,
    created_at timestamptz DEFAULT now()
) TABLESPACE pg_default;

CREATE OR REPLACE FUNCTION public.sync_profile_from_auth()
RETURNS trigger AS
$$
BEGIN
    INSERT INTO public.profiles (user_id, display_name, username, created_at)
    VALUES (
        NEW.id,
        split_part(NEW.email, '@', 1),
        split_part(NEW.email, '@', 1),
        now()
    )
    ON CONFLICT (user_id) DO UPDATE SET
        display_name = EXCLUDED.display_name,
        username = EXCLUDED.username,
        created_at = now();

    RETURN NEW;
END;
$$ LANGUAGE plpgsql
SET search_path = "public";

DROP TRIGGER IF EXISTS sync_profile_after_upsert on auth.users;

CREATE TRIGGER sync_profile_after_upsert
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_from_auth();

CREATE POLICY "Enable users to view their own data only" ON "public"."profiles" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "Enable delete for users based on user_id" ON "public"."profiles" FOR DELETE USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));

ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;

GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."profiles" TO "anon";
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."profiles" TO "authenticated";
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,TRUNCATE,UPDATE ON TABLE "public"."profiles" TO "service_role";



CREATE OR REPLACE FUNCTION public.share_with_self()
RETURNS trigger AS
$$
BEGIN
    INSERT INTO public.shared (user_id, doc_id)
    VALUES (
        NEW.user_id,
        NEW.doc_id
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql
SET search_path = "public";

DROP TRIGGER IF EXISTS share_with_self_trigger on public.documents;

CREATE TRIGGER share_with_self_trigger
AFTER INSERT ON public.documents
FOR EACH ROW EXECUTE FUNCTION public.share_with_self();